{"version":3,"sources":["ng://@polpware/fe-behavior/lib/state/finite-state-machine.ts"],"names":["_","dependencies.underscore","StateMachine","dependencies['statemachine']","indexOf","without","transitionKeyFormat","captialize","value","charAt","toUpperCase","slice","buildHandlerInClosure","context","key","ourHandlers","i","length","apply","arguments","defaultErrorHandler","eventName","from","to","info","replaceStr","name","console","log","FiniteStateMachine","this","_impl","_initState","_errorHandler","_stateConfiguration","_transitionConfiguration","_handlers","prototype","ensureConfigureStage","Error","ensureRunningStage","addState","onEnterCallback","onLeaveCallback","stateConf","setInitState","addTransition","onAfterCallback","onBeforeCallback","transitionConf","start","transitions","methods","k1","hasOwnProperty","elem1","push","k2","elem2","handlers","onEnterState","onLeaveState","init","onInvalidTransition","handler","onExitState","offEnterState","onenterstate","offExitState","onexitstate","go","is","currentState","state","transitionName","cannot","call","self","addErrorHandler","fn","current"],"mappings":"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","sourcesContent":["/**\n * @fileOverview\n * Provides a class representing a finite state machine.\n * @author Xiaolong Tang <xxlongtang@gmail.com>\n * @license Copyright @me\n */\nimport * as dependencies from '@polpware/fe-dependencies';\nimport { replace as replaceStr } from '@polpware/fe-utilities';\n\n// A set of helper functions\nconst _ = dependencies.underscore;\nconst StateMachine = dependencies['statemachine'];\nconst indexOf = _.indexOf;\nconst without = _.without;\nconst transitionKeyFormat = '{from}2{to}';\nconst errorMessageFormat = 'Transition {name} from {from} to {to} fails.';\n\n\nfunction captialize(value: string): string {\n    return value.charAt(0).toUpperCase() + value.slice(1);\n}\n\ninterface IUnderlyImpl {\n    state: string;\n    is(stateName: string): boolean;\n    cannot(transitionName: string): boolean;\n    fire(transitionName: string): any;\n}\n\ninterface ILifeCycleEvent {\n    transition: string;\n    from: string;\n    to: string;\n}\n\ntype MethodCallbackType = (ILifeCycleEvent) => void;\ntype ErrorHandlerType = (name: string, from: string, to: string) => void;\n\ninterface IStateSpecification {\n    onEnterCallback?: MethodCallbackType;\n    onLeaveCallback?: MethodCallbackType;\n}\n\ninterface ITransitionSpecification {\n    from: string;\n    to: string;\n    onBeforeCallback?: MethodCallbackType;\n    onAfterCallback?: MethodCallbackType;\n}\n\n/**\n * Builds a handler with necessary context information.\n * The resulting return value is a closure indeed.\n */\nfunction buildHandlerInClosure(context: { [key: string]: Array<MethodCallbackType> }, key: string) {\n    return function() {\n        const ourHandlers = context[key];\n        if (!ourHandlers) {\n            return;\n        }\n        for (let i = 0; i < ourHandlers.length; i++) {\n            const func = ourHandlers[i];\n            func.apply(null, arguments);\n        }\n    };\n}\n\n/**\n * Default error handler for the FSM.\n */\nfunction defaultErrorHandler(eventName: string, from: string, to: string): void {\n    const info = replaceStr(errorMessageFormat, {\n        name: eventName,\n        from: from,\n        to: to\n    });\n    console.log(info);\n}\n\n/**\n * Represents a finite state machine.\n * The resulting FSM is built upon a commonly used javascript\n * state machine library.\n * Such a design (of architecture) is based on the following considerations:\n * - A user-friendly interface for defining states and their behaviors\n * - A kind of model-checking capability for verifying the correctness of\n * transitions\n * - Support for asychronous and synchrous transitions\n * - Support for global exception handling\n * @class FSM\n */\nexport class FiniteStateMachine {\n\n    private _impl: IUnderlyImpl;\n    private _initState: string;\n    private _errorHandler: ErrorHandlerType;\n    private _stateConfiguration: { [key: string]: IStateSpecification };\n    private _transitionConfiguration: { [key: string]: ITransitionSpecification };\n    private _handlers: { [key: string]: Array<MethodCallbackType> };\n\n    constructor() {\n        this._impl = null;\n        this._initState = null;\n        this._errorHandler = null;\n        this._stateConfiguration = {};\n        this._transitionConfiguration = {};\n        this._handlers = {};\n    }\n\n    /**\n     * Checks if FSM is in configuration stage.\n     */\n    private ensureConfigureStage() {\n        if (this._impl) {\n            throw new Error('State machine has started.');\n        }\n    }\n\n    /**\n     * Checks if FSM is in running stage.\n     */\n    private ensureRunningStage() {\n        if (!this._impl) {\n            throw new Error('State machine has not yet started.');\n        }\n    }\n\n    /**\n     * Defines the behavior when the FSM moves into a state by a transition.\n     */\n    addState(name: string,\n        onEnterCallback?: MethodCallbackType,\n        onLeaveCallback?: MethodCallbackType) {\n        // Pre-conditions\n        this.ensureConfigureStage();\n        const stateConf = this._stateConfiguration;\n        if (stateConf[name]) {\n            throw new Error('Redefined state: ' + name);\n        }\n        stateConf[name] = {\n            onEnterCallback: onEnterCallback,\n            onLeaveCallback: onLeaveCallback\n        };\n        return this;\n    }\n\n    /**\n     * Defines the init state for the FSM.\n     */\n    setInitState(name: string) {\n        // Pre-conditions\n        this.ensureConfigureStage();\n\n        if (this._initState) {\n            throw new Error('Redefined init state: ' + this._initState);\n        }\n        this._initState = name;\n        return this;\n    }\n\n    /**\n     * Defines a new stransition.\n     */\n    addTransition(from: string,\n        to: string,\n        onAfterCallback?: MethodCallbackType,\n        onBeforeCallback?: MethodCallbackType) {\n        // Pre-condition\n        this.ensureConfigureStage();\n\n        const stateConf = this._stateConfiguration;\n        const transitionConf = this._transitionConfiguration;\n        if (!stateConf[from]) {\n            throw new Error('Undefined source state: ' + from);\n        }\n        if (!stateConf[to]) {\n            throw new Error('Undefined target state: ' + to);\n        }\n        const key = replaceStr(transitionKeyFormat, { from: from, to: to });\n        if (transitionConf[key]) {\n            throw new Error('Redefined transition: ' + from + ' -> ' + to);\n        }\n        transitionConf[key] = {\n            from: from, to: to,\n            onAfterCallback: onAfterCallback,\n            onBeforeCallback: onBeforeCallback\n        };\n        return this;\n    }\n\n    /**\n     * Starts the FSM. Note that this method must be invoked before\n     * any method which may change the state of the FSM.\n     */\n    start() {\n\n        this.ensureConfigureStage();\n        if (!this._initState) {\n            throw new Error('Init state has not been defined.');\n        }\n\n        // Definition\n        const stateConf: Object = this._stateConfiguration;\n        const transitionConf: Object = this._transitionConfiguration;\n\n        const transitions: Array<{ name: string, from: string, to: string }> = [];\n        const methods: { [key: string]: MethodCallbackType } = {};\n\n        for (const k1 in transitionConf) {\n            if (transitionConf.hasOwnProperty(k1)) {\n                const elem1 = transitionConf[k1];\n                transitions.push({\n                    name: k1,\n                    from: elem1.from,\n                    to: elem1.to\n                });\n\n                if (elem1.onAfterCallback) {\n                    methods['onAfter' + captialize(k1)] = elem1.onAfterCallback;\n                }\n                if (elem1.onBeforeCallback) {\n                    methods['onBefore' + captialize(k1)] = elem1.onAfterCallback;\n                }\n            }\n        }\n\n        for (const k2 in stateConf) {\n\n            if (stateConf.hasOwnProperty(k2)) {\n                const elem2 = stateConf[k2];\n\n                if (elem2.onEnterCallback) {\n                    methods['onEnter' + captialize(k2)] = elem2.onEnterCallback;\n                }\n                if (elem2.onLeaveCallback) {\n                    methods['onLeave' + captialize(k2)] = elem2.onLeaveCallback;\n                }\n            }\n        }\n\n        const handlers = this._handlers;\n        handlers.onEnterState = [];\n        handlers.onLeaveState = [];\n\n        methods['onEnterState'] = buildHandlerInClosure(this._handlers, 'onEnterState');\n        methods['onLeaveState'] = buildHandlerInClosure(this._handlers, 'onLeaveState');\n\n        this._impl = new StateMachine({\n            init: this._initState,\n            transitions: transitions,\n            methods: methods,\n            onInvalidTransition: this._errorHandler || defaultErrorHandler\n        });\n        return this;\n    }\n\n    /**\n     * Registers a handler for enterstate\n     */\n    onEnterState(handler: MethodCallbackType) {\n        const ourHandlers = this._handlers.onEnterState;\n        if (indexOf(ourHandlers, handler) >= 0) {\n            throw new Error('Re-registering a hander!');\n        }\n        ourHandlers.push(handler);\n        return this;\n    }\n\n    /**\n     * Registers a handler for exitstate\n     */\n    onExitState(handler: MethodCallbackType) {\n        const ourHandlers = this._handlers.onLeaveState;\n        if (indexOf(ourHandlers, handler) >= 0) {\n            throw new Error('Registering a hander!');\n        }\n        ourHandlers.push(handler);\n        return this;\n    }\n\n    /**\n     * Un-register a handler for enterstate\n     */\n    offEnterState(handler: MethodCallbackType) {\n        const ourHandlers = this._handlers.onEnterState;\n        this._handlers.onenterstate = without(ourHandlers, handler);\n        return this;\n    }\n\n    /**\n     * Un-register a handler for exitstate\n     */\n    offExitState(handler: MethodCallbackType) {\n        const ourHandlers = this._handlers.onLeaveState;\n        this._handlers.onexitstate = without(ourHandlers, handler);\n        return this;\n    }\n\n    /**\n     * Performs a transition to the given state.\n     * This method also validate the transition.\n     */\n    go(to: string) {\n        this.ensureRunningStage();\n\n        const stateConf = this._stateConfiguration;\n        if (!stateConf[to]) {\n            throw new Error('Go to undefined state: ' + to);\n        }\n        if (this._impl.is(to)) {\n            // TODO: check if the underlying implementation takes into account\n            // moving from one state to itself\n            return this;\n        }\n        const currentState = this._impl.state;\n        const transitionName = replaceStr(transitionKeyFormat, { from: currentState, to: to });\n        // Validate if this transition is allowed or not\n        if (this._impl.cannot(transitionName)) {\n            throw new Error('Transition is not allowed: ' + currentState + ' -> ' + to);\n        }\n\n        // Invoke this function\n        const func = this._impl[transitionName];\n        func.call(this._impl);\n        return self;\n    }\n\n    /**\n     * Provides the error handler for the FSM.\n     */\n    addErrorHandler(fn: ErrorHandlerType) {\n        this.ensureConfigureStage();\n\n        this._errorHandler = fn;\n\n        return this;\n    }\n\n    /**\n     * Returns the current state.\n     */\n    current() {\n        this.ensureRunningStage();\n        return this._impl.state;\n    }\n}\n"]}